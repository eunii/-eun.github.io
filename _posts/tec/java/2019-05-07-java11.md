---
title: "[Java의정석] CH12. 쓰레드"
categories:
   [tec, java]
tags:
   [java]
   
toc: true
toc_label: "CH12. 쓰레드"

---

## 1. 프로세스와 쓰레드
프로세스(process)는 간단하게 말하면 실행중인 프로그램이다.  
**프로그램 --실행--> 프로세스**   
프로세스는 데이터, 메모리등의 자원과 쓰레드로 구성되어있음.  
프로세스의 자원을 이용해서 실제 작업을 수행하는 것.  
모든 프로세스는 최소 하나 이상의 쓰레드가 존재. 둘 이상이면 멀티쓰레드 프로세스라한다.  

- 멀티쓰레딩의 장점
    - CPU의 사용률을 향상시킴.
    - 자원을 보다 효울적으로 사용할 수 있음.
    - 사용자에 대한 응답성이 향상됨.
    - 작업이 분리되어 코드가 간결해짐. 

동기화(synhronization), 교착상태(deadlock)등을 고려해서 신중히 프로그래밍 해야함.

## 2. 쓰레드의 구현과 실행 
구현 방법
1. Thread클래스 상속
```java
class MyThread extends Thread{
    public void run(){
        //Thread의 run()함수를 오버라이딩.
    }
}
```
2. Runnable인터페이스 구현(일반적인 방법)
```java
class MyThread implements Runnable{
    public void  run(){
        //추상메서드 run()을 구현
    }
}
```
```java
class ThreadEx1{
    public static void main(String[] args){
      ThreadEx1_1 t1 = new ThreadEx1_1();
      
      Runnable r = new ThreadEx1_2();
      Thread t2 = new Thread(r);
    }
}

class ThreadEx1_1 extends Thread{
    public void run(){
        for(int i = 0; i < 5; i++) {
            System.out.println(getName());
        }
    }
}

class ThreadEx1_2 implements Runnable{
    public void run(){
        for(int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}
```
쓰레드 생성 후 start()를 호출해야 작업을 시작함.  
한번 사용한 쓰레드는 다시 재사용할 수 없다. 하나의 쓰레드에 한번의 start()만 호출 될 수 있음.  
```java
ThreadEx1_1 t1 = new ThreadEx_1();
t1.start();
t.start();//이건 불가능
```
```java
ThreadEx1_1 t1 = new ThreadEx1_1();
t1.start();
t1 = new ThreadEx1_1();
t.start();//이건 가능
```

## 3. start()와 run()
- run()을 호출하는 것은 생성된 쓰레드를 실행하는 것이 아니라 단순히 클래스에속한 메서드를 하나 호출하는것.  

---
call stack  

run  
main  
---  

- start()을 호출하는 것은 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 후 run()을 호출해서 생성된 호출스택에 run()이 저장되게 한다.  
모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하기 때문에 새로운 쓰레드를 생성하고 실행시킬때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다.  

1. main메서드에서 쓰레드의 start메서드를 호출한다.
2. start메서드는 쓰레드가 작업을 수행하는데 사용될 새로운 호출 스택을 생성한다. 
3. 생성된 호출스택에 run 메서드를 호출해서 쓰레드가 작업을 수행하도록 한다. 
4. 이제는 호츨스택이 2개이기때문에 스케줄러가 정한 순서에 으해 번갈아 가면서 실행된다.   

실행중인 쓰레드가 하나도 없을때 프로그램은 종료된다.

## 4. 싱글쓰레드와 멀티쓰레드
두개의 작업을 하나의 쓰레드로 하면 한 작업 끝난 후 다른 작업 끝.
두개의 작업을 두개의 쓰레드로 하면 짧은시간동안 쓰레드 2개가 번갈아 가면서 작업을 수행해서 동시에 두 작업이 처리되는것과 같다고 느낌.
CPU만 사용하는 계산 작업이면 멀티쓰레드가 전환하는 시간때문에 오히려 느림.
CPU외 자원을 사용하는 경우 싱글쓰레드 프로세스 보다 멀티쓰레드프로세스가 더 효율적임.
ex)외부기기에서 입출력 받는 경우
```java
import javax.swing.JOptionPane;

class ThreadEx6{
    public static void main(String[] args) throws Exception{
        String input = JOptionPanel.showInputDialog("아무 값이나 입력하세요.");
        System.out.println("입력하신 값은 "+input+"입니다.");
        
        for(int i = 10; i > 0 ; i--) {
          System.out.println(i);
          try{
              Thread.sleep(1000);
          }catch(Exception e){}
        }
    }
}
```
위의 예는 입력을 받은 후 출력하기 때문에 사용자가 입력하는 동안에는 출력 작업이 일어나지 않는다. 
```java
import javax.swing.JOptionPane;

class ThreadEx7{
    public static void main(String[] args) throws Exception{
        
        ThreadEx7_1 th1 = new ThreadEx7_1();
        th1.start();
        
        String input = JOptionPanel.showInputDialog("아무 값이나 입력하세요.");
        System.out.println("입력하신 값은 "+input+"입니다.");
       
    }
}
class ThreadEx7_1 extends Thread{
    public void run(){
        for(int i = 10; i > 0 ; i--) {
           System.out.println(i);
           try{
                Thread.sleep(1000);
           }catch(Exception e){}
          
        }
    }
}
```
위의 코드는 입력받는 동안 출력되고 입력된 값이 출력되고 또 출력이 된다.

## 5. 쓰레드의 우선순위
쓰레드에 우선순위(priority)의 멤버변수가 있다.  
우선순위의 범위는 1~10이고 숫자가 높을수록 더 우선순위가 높다.  
우선순위의 값은 상대적이다. 1,2와 8,9의 결과 값이 같다. 
우선순위는 쓰레드생성한 쓰레드로부터 상속받는다.   
main 메서드를 수행하는 쓰레드의 우선순위는 5.  
파일 다운로드와 채팅기능 중 채팅에 더 우선순위를 높여야 한다.  
```java
void setPripority(int new Priority);
int getPriority();

public static final int MAX_PRIORITY =10;
public static final int MIN_PRIORITY =1;
public static final int NORM_PRIORITY = 5;
```

```java
class ThreadEx9{
    public static void main(String[] args) throws Exception{
        
        ThreadEx9_1 th1 = new ThreadEx9_1();
        ThreadEx9_2 th2 = new ThreadEx9_2();
        th2.setPriority(7);
        System.out.println("입력하신 값은 "+input+"입니다.");
        th1.start();
        th2.start();       
    }
}

class ThreadEx9_1{
    public void run(){
        for(int i = 0; i < 300 ; i++) {
          System.out.println("-");
          for(int j = 0; j < 1000000 ; j++) {}
        }
    }
}
class ThreadEx9_2{
    public void run(){
        for(int i = 0; i < 300 ; i++) {
          System.out.println("|");
          for(int j = 0; j < 1000000 ; j++) {}
        }
    }
}
```
위 결과는 |가 먼저 끝나고, - 이 완료된다.

## 6. 쓰레드 그룹(thread group)
서로 관련된 쓰레드를 그룹으로 다루기 위한것.  
폴더를 생성해서 관련된 파일을 묶어 관리하는것처럼 쓰레드도 그룹으로 묶어서 관리.  
쓰레드를 쓰레드 그룹에 포함시키려면 Thread생성자를 이용해야함
```java
Thread(ThreadGroup group, String name)
Thread(ThreadGroup gorup, Runnable target)
```

## 7. 데몬쓰레드(deamon thread)
데몬쓰레드는 일반 쓰레드의 작업을 돕는 보조역할.  
일반쓰레드 작업이끝나면 데몬 쓰레드는 강제종료됨.  
ex) 가비지컬렉터, 위드프로세서 자동저장, 화면자동갱신  
무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건이 되면 작업 수행하고 다시 대기.  

## 8. 쓰레드의 실행제어

## 9. 쓰레드의 동기화
